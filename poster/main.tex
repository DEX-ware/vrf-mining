\documentclass[sigconf]{acmart}

\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{interval}
\usepackage{amsmath, amssymb}
\usepackage{cuted, tcolorbox}
\usepackage{tikz}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}

\usepackage[normalem]{ulem}

\makeatletter
\newcommand{\printfnsymbol}[1]{%
  \textsuperscript{\@fnsymbol{#1}}%
}
\makeatother

\newcommand{\RH}[1]{\textcolor{blue}{#1}}
\newcommand{\JS}[1]{\textcolor{red}{#1}}
\newcommand{\TODO}[1]{\textcolor{red}{TODO: #1}}
\newcommand{\HY}[1]{\textcolor{brown}{#1}}

% blue comment
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
% blue triangle
\SetKwComment{Comment}{\color{blue} $\triangleright$\ }{}


\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column
\pagestyle{plain} % removes running headers

\begin{document}

\title{VRF-based mining: How to make pooled mining impossible?}

\author{Runchao Han}
\affiliation{%
  \institution{Monash University and CSIRO-Data61}}
\email{runchao.han@monash.edu}

\author{Haoyu Lin}
\affiliation{}
\email{chris.haoyul@gmail.com}

\author{Jiangshan Yu}
\affiliation{%
  \institution{Monash University}}
\email{jiangshan.yu@monash.edu}

\maketitle




\section{Introduction}
\label{sec:intro}

Bitcoin~\cite{nakamoto2008bitcoin} started the era of cryptocurrency.
Bitcoin's main novelty is Nakamoto consensus - the first consensus protocol that can work in permissionless settings.
Due to the similarity, participants of Nakamoto consensus are called miners, the process of solving PoW puzzles called mining, and the computation power used for mining is known as mining power.

% why pooled mining
Today, however, mining pools dominate the mining power of most blockchains using Nakamoto consensus, which contradicts the design objective of Bitcoin - the decentralisation.
Mining pool is a kind of service that gathers mining power from solo miners and rewards solo miners in a more fine-grained way.
To date (01/12/2019), four largest mining pools control more than 51\% Bitcoin mining power~\cite{btc-com}, which can be a lurking threat of Bitcoin.

In this work, we introduce \textit{VRF-based mining}, a novel idea of using Verifiable Random Functions (VRFs) rather than hash functions for mining in PoW-based consensus.
With VRF, a miner should use his private key to mine blocks, so a pool operator should reveal his private key in order to outsource the mining process to miners.
In this way, no one can outsource the mining process, otherwise any miner can steal all cryptocurrency in his wallet anonymously.



\section{Verifiable random functions}

Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
In addition to the input string, VRF involves a pair of a secret key and a public key.
Given an input string and a secret key, one can compute a hash.
Anyone knowing the associated public key can verify the correctness of the hash, and can also verify the hash is generated by the owner of the secret key.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $(sk, pk) \gets \mathsf{VRFKeyGen}(1^{\lambda})$: on input a security parameter $1^{\lambda}$, outputs the secret/public key pair $(sk, pk)$.
    \item $\beta \gets \mathsf{VRFHash}(sk, \alpha)$: on input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length hash $\beta$.
    \item $\pi \gets \mathsf{VRFProve}(sk, \alpha)$: on input $sk$ and $\alpha$, outputs the proof $\pi$ for $\beta$.
    \item $\{0, 1\} \gets \mathsf{VRFVerify}(pk, \alpha, \beta, \pi)$: on input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result 0 or 1.
\end{itemize}

\section{VRF-based mining}
\label{sec:construction}

% intuitive
Instead of using a hash function, VRF-based mining uses a VRF to produce hashes that satisfy the difficulty requirement.
Different from hash functions, VRF takes both an input and a secret key to produce a hash.
In addition, the owner of this secret key can produce a proof proving that the hash is generated by himself.
Thus, to outsource the mining process, the pool operator should show his secret key to miners.
However, with the secret key, any miner in the mining pool can steal all coins of the pool operator.

\begin{algorithm}[]
\caption{$\mathsf{Work}(sk, t, Target)$.}
\label{algo:work}
\SetAlgoLined\DontPrintSemicolon
\KwIn{The secret key $sk$, the block template $t$, and the difficulty parameter $Target$}
\KwOut{The block $blk$, the VRF output $h$, and the VRF proof $\pi$}
  Initialise $n$, $h$, $blk$ \Comment*[r]{Initialise variables}
  \While (\Comment*[f]{Refresh the nonce}) {$n \gets \mathsf{NextNonce}()$}{
    $blk \gets \mathsf{ConstructBlock}(t, n)$ \Comment*[r]{Assemble the block}
    $h \gets \mathsf{VRFHash}(sk, blk)$ \Comment*[r]{Produce the VRF output}
    \If (\Comment*[f]{If meeting difficulty}) {$h < Target$}{
      break \Comment*[r]{Mining successful}
    }
  }
  $\pi \gets \mathsf{VRFProve}(sk, blk)$ \Comment*[r]{Produce the proof}
  \Return{$blk$, $h$, $\pi$} \Comment*[r]{Return block, hash and proof}
\end{algorithm}



\begin{algorithm}[h]
\caption{$\mathsf{Verify}(blk, h, \pi, Target)$}
\label{algo:verify}
\SetAlgoLined\DontPrintSemicolon
$pk \gets blk . txs[0] . scriptPubKey$ \Comment*[r]{Find pubkey in coinbase tx}
$\mathsf{require}(h < Target)$ \Comment*[r]{Hash should meet diff requirement}
\tcc{Here $\mathsf{VRFVerify}(\cdot)$ ensures:\\
1. $h$ is generated by the owner of $sk$\\
2. $h$ is the valid output of $\mathsf{VRFHash}(sk, blk)$}
$\mathsf{require}(\mathsf{VRFVerify}(pk, blk, h, \pi))$ \;
$\dots$ \Comment*[l]{Verify other fields}
$\dots$ \Comment*[l]{Verify transactions}
\end{algorithm}

Cryptocurrency mining consists of two components, namely mining blocks and verifying blocks.
We call the process of mining a block $\mathsf{Work}$, and the process of verifying a block $\mathsf{Verify}$.
Algorithm~\ref{algo:work} and \ref{algo:verify} describe $\mathsf{Work}$ and $\mathsf{Verify}$, respectively.

\textbf{Work.}
Miners run $\mathsf{Work}$ to mine new blocks.
More specifically, a miner - with his private key $sk$ the block template (a complete block without nonce) $t$ - keeps searching for a nonce $n$ that can make the (VRF) hash $h$ of the block $blk$ to meet the difficulty requirement $Target$.
Once finding a valid $n$, the miner produces the proof $\pi$ of $h$, and appends $blk$ (with $n$), $h$ and $\pi$ to the blockchain.

\textbf{Verify.}
Upon incoming blocks, miners run $\mathsf{Verify}$ to verify their validity.
While other verifications are the same as in hash-based mining, $\mathsf{Verify}$ in VRF-based mining should additionally run $\mathsf{VRFVerify}(\cdot)$ to verify 1) whether $h$ is produced by the owner of $sk$, and 2) whether $h$ is a valid output of $\mathsf{VRFHash}(sk, blk)$.

\textbf{Block structure.}
Different from hash-based mining, in VRF-based mining the blockchain should additionally attach $h$ and $\pi$, but does not need the signature of a block.
Other miners without knowing $sk$ cannot produce $h$, but can use $\pi$ to verify $h$ is generated by someone knowing $sk$.
Through proving the authorship of $h$, $\pi$ also proves the authorship of the block.
Thus, miners only need to sign $h$, but do not need to sign blocks.








\section{Non-outsourceability analysis}
\label{sec:non_outsourceability}

\subsection{Revised definitions}

Miller et al. \cite{miller2015nonoutsourceable} first formally defines cryptocurrency mining and non-outsourceability.
In particular, they define two levels of non-outsourceability, namely \textbf{Weak Non-outsourceability} and \textbf{Strong Non-outsourceability}.
\textbf{Weak Non-outsourceability} defines the punishment of outsourcing, while \textbf{Strong Non-outsourceability} covers both the punishment and the anonymity of malicious miners.
We call the property defining the punishment of outsourcing \textbf{Punish-mining-reward}.
The anonymity of malicious miners defined in~\cite{miller2015nonoutsourceable} is equivalent to \textbf{Transaction Unlinkability}~\cite{van2013cryptonote}: given two arbitrary transactions, distinguishing whether they have the same output address requires knowing the private keys holding their outputs.
To steal the mining reward, the miner should create a transaction, of which the input is the mining reward and the output is his owned address.
Identifying who steals the mining reward is equivalent to finding out who holds the output address, which can be further reduced to \textbf{Transaction Unlinkability}.


\subsection{Punish-secret-key-leakage}

% SK-non-outsourceability
We introduce \textbf{Punish-secret-key-leakage}, a new property of punishment on outsourcing that achieves stronger non-outsourceability than \textbf{Punish-mining-reward}.
A cryptocurrency mining protocol achieves \textbf{Punish-secret-key-leakage} in the following sense: the pool operator should reveal 1) the block template and 2) the private key receiving the coinbase transaction, so that miners can mine in the name of the pool operator.

\subsection{Non-outsourceability of VRF-based mining}

VRF-based mining achieves both \textbf{Punish-secret-key-leakage} and \textbf{Transaction Unlinkability}.
In VRF-based mining, the pool operator outsources mining requires revealing his private key to miners, which leads to \textbf{Punish-secret-key-leakage}.
Similar with the construction achieving \textbf{Strong Non-outsourceability} in~\cite{miller2015nonoutsourceable}, VRF-based mining achieves \textbf{Transaction Unlinkability} by allowing a malicious miner to use a freshly generated address to steal cryptocurrency.
To receive the stolen cryptocurrency of the pool operator, the malicious miner can create a new address, and construct a transaction of which the stolen cryptocurrency directs to this address.
As this new address has no historical transactions, linking the transaction stealing cryptocurrency with other transactions can be impossible.
Then the malicious miner can then spend his stolen cryptocurrency anonymously using numerous techniques, such as mixing services~\cite{maxwell2013coinjoin}\cite{bonneau2014mixcoin}\cite{ruffing2014coinshuffle}\cite{heilman2017tumblebit} and stealth addresses~\cite{van2013cryptonote}.




\section{Instantiating VRF}
\label{sec:instantiation}

To implement VRF-based mining, one needs to first instantiate the VRF.
VRF in~\cite{goldberg2017draft} has four configurable components: the elliptic curve and three hash functions.
In this section, we discuss considerations on choosing these four components for VRF-based mining.

\subsection{Elliptic curve}

As neither blockchains and VRF limits the choice of elliptic curves, any elliptic curve can be adapted.
Among prominent elliptic curves, Curve25519~\cite{bernstein2006curve25519} can be a promising choice.
First, Curve25519 works on a prime field with the prime number $2^{255} - 19$, which provides sufficient enumeration space for VRF.
Second, Curve25519 supports Ed25519~\cite{bernstein2012high}, a fast and secure digital signature algorithm.
Last, Curve25519 is compatible with existing blockchains: numerous blockchains and projects using VRF adapt Curve25519 as their underlying elliptic curve.




\subsection{$H_{1}(\cdot)$ (Hashing a string to an elliptic curve point)}

% indistinguishable
$H_{1}(\cdot)$ is a hash-to-curve function, which should prevent distinguishing behaviours: adversaries cannot learn any pattern of the input from its hash.
% deterministic
In addition, the hash-to-curve function used in VRF should be deterministic, otherwise the hash will be unreproducible.

A standardisation document~\cite{scott2019hashing} specifies several hash-to-curve functions that fit into different elliptic curves and satisfy our requirements: Icart Method~\cite{icart2009hash}, Shallue-Woestijne-Ulas Method~\cite{ulas2007rational}, Simplified SWU Method~\cite{brier2010efficient} and Elligator2~\cite{bernstein2013elligator}.
Within these hash-to-curve functions, Elligator2 is the recommended one for Curve25519.




\subsection{$H_{2}(\cdot)$ (Hashing an elliptic curve point to a string)}

$H_{2}(\cdot)$ hashes an elliptic curve point to a fixed-length string.
It can be divided to two steps: 1) encoding an elliptic curve point to a string, and 2) hashing the string using a normal hash function.
The encoding step can be bidirectional and unencrypted, so can be done simply by converting a big integer to a string.
The hashing step should be cryptographically secure, so can adapt any existing cryptographically secure hash functions.

For ASIC-resistant cryptocurrencies using memory-hard hash functions (e.g., Ethereum~\cite{wood2014ethereum} and Monero~\cite{monero}), there are some concerns on choosing hash functions in $H_{2}(\cdot)$.
% VRFHash shoule memory-hard
To make mining memory-hard, $\mathsf{VRFHash}$ should be memory-hard.
% vrfhash steps
$\mathsf{VRFHash}$ of the standardised VRF consists of one $H_{1}(\cdot)$ hashing, one scalar-point multiplication and one $H_{2}(\cdot)$ hashing.
$H_{1}(\cdot)$ and the encoding step in $H_{2}(\cdot)$ can be fast so less possible to become the performance hotspot.
The scalar-point multiplication is slow and computation (rather than memory)-intensive.
% make VRFHash memory hard
The hash function in $H_{2}(\cdot)$ is the only possibility to make $\mathsf{VRFHash}$ memory-hard, and it should be overwhelmingly slower than the scalar-point multiplication, otherwise the scalar-point multiplication will make $\mathsf{VRFHash}$ computation-intensive.
This requirement can be achieved by repetitively executing one or multiple different memory-hard hash functions (such as Ethash~\cite{wiki2017ethash}, Equihash~\cite{biryukov2017equihash}, and CryptoNight~\cite{seigenneocortex}).



\subsection{$H_{3}(\cdot)$ (Normal hash function)}

$H_{3}(\cdot)$ is only used in $\mathsf{VRFProve}$ (proving the authorship of hashes) and $\mathsf{VRFVerify}$ (verifying the authorship of hashes).
The overhead of proving and verification should be minimised, so cryptographically secure hash functions that are designed to be fast (such as Keccak~\cite{bertoni2013keccak} and BLAKE~\cite{aumasson2008sha}) are suitable for $H_{3}(\cdot)$.






\bibliographystyle{acm}
\bibliography{refs}

\end{document}