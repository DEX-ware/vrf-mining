\section{Sybil-resistance v.s. incentive compatibility}

\subsection{Why consensus requires mining}

Nakamoto consensus requires PoW minig because it is designed that the consensus blockchain is the chain with the greatest PoW effort accumulated and therefore the greatest the greatest difficulty to produce, usually the longest chain.
Such a chain is chosen as the majority agreement because it is the most difficult one to manipulate.

Moreover, PoW can provide the blockchain with Sybil-resistance.
Sybil attack is to subvert a reputation system by forging indentities.
In PoW-style blockchains, the miner mines the new block is identically the leader producing the new block.
That is to say, mining is to create the identity to be elected as the leader.
As PoW requires computations, such a identity creation is neither costless.
Therefore, PoW-style blockchains resist Sybil attacks by making identities generation expensive.

\subsection{Why miners join mining}

PoW-style blockchains incentivise miners to maintain the transaction history.

Block subsidy and transaction fees are to encourage miners to keep recording new transaction.
This help provide the blockchain with liveness: new blocks and valid transactions with appropriate feed will continue to be added to the ledger.

The incentive also motivate the miners to stay honest and is to achieve incentive compatibility~\cite{}.
Because the agreed chain has the corresponding PoW effort accumulated, to alter the history and double-spend his money, a miner needs to control a considerable amount of hash power to redo the PoW of the block, in which his first transaction was included, and all the following blocks since it.
A miner owning such a computing power may choose between using it to double spend his money, or using it to mine new blocks and get rewarded. 

To keep the blockchain system running expectedly, the reward needs to be profitable.
Therefore, miners are incentivised to join mining.

\subsection{Why miners join mining pools}

\TODO{can delegate}

\TODO{won't steal? present for pool? see https://bitcointalk.org/index.php?topic=309073}

As aforementioned, unsteady income stream will be risky, but the probability of a miner find a solution is in propotion to to the his hash power.
Therefore, in pratice, miners often join a mining pool and perform computation on behalf of the pool, and get more stable funds allocatd to them by the pool operators.
However, this leads to the centralisation of computation power.

\subsection{Balancing the sybil resistance and incentive}

We have addressed in Section~\ref{sec:discourage-pool} that, our sheme completely discourage a rational pool operator who wants get mining rewards.
However, there still remains a concern that, we need to make a trade-off between Sybil resistance and incentivising miners to join mining.

\HY{I find it difficult to connect it with Quadratic Voting or with Radical Market, so I skip it.}

Assumes we have 2 different mining algorithms A and B, of which the computation-power-vs-investment-on-hardware curves are shown in Figure~\ref{fig:algo_A} and Figure~\ref{fig:algo_B} respectively.

For algorithm A, with fewever investment on hardware, a miner can gain relativly higher computing power than B. That is, it is cheaper to generate identity, and hence it is less sybil-resistant.

However, if using algorithm B, though it can bring stronger sybil resistance to the system, a miner will find that he cannot gain significant hash power unless he invest enough on the hardware.
As aforementioned in Section~\ref{sec:intro}, low minig power will lead to unstable payouts, which will undoubtedly disincentivize miners if their budget are limited.

Therefore, when designing the VRF, we need to take into account balancing the sybil resistance and incentive.

\begin{figure}
\centering
\begin{tikzpicture}
  \draw[->] (0,0) -- (6,0) node[right] {{Investment on Hardware}};
  \draw[->] (0,0) -- (0,5) node[above] {{Hash Power}};
  \draw (0,0) .. controls (3,0) and (4,0) .. (5,4.5);
\end{tikzpicture}
\caption{Algorithm A}
\label{fig:algo_A}
\end{figure}


\begin{figure}
\centering
\begin{tikzpicture}
  \draw[->] (0,0) -- (6,0) node[right] {{Investment on Hardware}};
  \draw[->] (0,0) -- (0,5) node[above] {{Hash Power}};
  \draw (0,0) .. controls (0,3) and (0,4) .. (5,4.5);
\end{tikzpicture}
\caption{Algorithm B}
\label{fig:algo_B}
\end{figure}
