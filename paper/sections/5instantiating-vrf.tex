\section{Instantiating VRF}
\label{sec:instantiation}

In order to implement VRF-based mining, one needs to first instantiate the VRF.
VRF in Algorithm~\ref{algo:standard-ecvrf} has four configurable components, including the elliptic curve and three hash functions.
Three hash functions are:
$H_{1}(\cdot)$ mapping an arbitrary-length string into an elliptic curve element,
$H_{2}(\cdot)$ mapping an elliptic curve element into a fixed-length string, and
$H_{3}(\cdot)$ mapping an arbitrary-length string into a fixed-length string.
In this section, we discuss considerations on choosing these four components for VRF-based mining.





\subsection{Elliptic curve}

As neither blockchains and VRF limits the choice of elliptic curves, any elliptic curve can be adapted.
Among prominent elliptic curves, Ed25519~\cite{bernstein2012high} can be a promising choice.
First, Ed25519 works on a prime field with the prime number $2^{255} - 19$, which provides sufficient enumeration space for VRF.
Second, Ed25519 supports EdDSA, a fast and secure digital signature algorithm.
Last, Ed25519 is compatible with existing blockchains: numerous blockchains and projects using VRF adapt Curve25519 as their underlying elliptic curve.




\subsection{Hashing a string to an elliptic curve point $H_{1}(\cdot)$}

% indistinguishable
$H_{1}(\cdot)$ is a hash-to-curve function, which should prevent distinguishing behaviours: adversaries cannot learn any pattern of the input from its hash.
% deterministic
In addition, the hash-to-curve function used in VRF should be deterministic, otherwise the hash will be unreproducible.

A standardisation document~\cite{scott2019hashing} specifies several hash-to-curve functions that fit into different elliptic curves and satisfy our requirements: Icart Method~\cite{icart2009hash}, Shallue-Woestijne-Ulas Method~\cite{ulas2007rational}, Simplified SWU Method~\cite{brier2010efficient} and Elligator2~\cite{bernstein2013elligator}.
Within these hash-to-curve functions, Elligator2 is the recommended one for Curve25519.




\subsection{Hashing an elliptic curve point to a string $H_{2}(\cdot)$}

$H_{2}(\cdot)$ hashes an elliptic curve point to a fixed-length string.
It can be divided to two steps: 1) encoding an elliptic curve point to a string, and 2) hashing the string using a normal hash function.
The encoding step can be bidirectional and unencrypted, so can be done simply by converting a big integer to a string.
The hashing step should be cryptographically secure, so can adapt any existing cryptographically secure hash functions.


\subsection{Normal hash function $H_{3}(\cdot)$}

$H_{3}(\cdot)$ is only used in $\mathsf{VRFProve}$ (proving the authorship of hashes) and $\mathsf{VRFVerify}$ (verifying the authorship of hashes).
The overhead of proving and verification should be minimised, so cryptographically secure hash functions that are designed to be fast (such as Keccak~\cite{bertoni2013keccak} and BLAKE~\cite{aumasson2008sha}) are suitable for $H_{3}(\cdot)$.

\subsection{Memory-hard mining}

For ASIC-resistant cryptocurrencies using memory-hard hash functions (e.g., Ethereum~\cite{wood2014ethereum} and Monero~\cite{monero}), there are some concerns on designing $H_{1}(\cdot)$ and $H_{2}(\cdot)$.
% VRFHash shoule memory-hard
To make mining memory-hard, $\mathsf{VRFHash}$ should be memory-hard.
% vrfhash steps
$\mathsf{VRFHash}$ of the standardised VRF consists of one $H_{1}(\cdot)$ hashing, one scalar-point multiplication and one $H_{2}(\cdot)$ hashing.
Thus, making VRF-based mining memory-hard can be achieved by making $H_{1}(\cdot)$ or $H_{2}(\cdot)$ memory-hard.
This can be achieved by repetitively executing one or multiple different memory-hard hash functions (such as Ethash~\cite{wiki2017ethash} and CryptoNight~\cite{seigenneocortex}).