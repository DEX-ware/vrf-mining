\section{VRF-based mining}
\label{sec:construction}

% intuitive
Instead of using a hash function, VRF-based mining uses a VRF to produce hashes that satisfy the difficulty requirement.
VRF takes both an input and a secret key to produce a hash.
The owner of this secret key can produce a proof proving the ownership of his hash.
Thus, to outsource the mining process, the pool operator should show his secret key to miners.
However, with the secret key, any miner in the mining pool can steal all coins of the pool operator.

\begin{algorithm}[]
\caption{$\mathsf{Work}(sk, t, Target)$.}
\label{algo:work}
\SetAlgoLined\DontPrintSemicolon
\KwIn{The secret key $sk$, the block template $t$, and the difficulty parameter $Target$}
\KwOut{The block $blk$, the VRF output $out$, and the VRF proof $\pi$}
  Initialise $n$, $out$, $blk$ \Comment*[r]{Initialise variables}
  \While (\Comment*[f]{Refresh the nonce}) {$n \gets \mathsf{NextNonce}()$}{
    $blk \gets \mathsf{ConstructBlock}(t, n)$ \Comment*[r]{Assemble the block}
    $out \gets \mathsf{VRFHash}(sk, blk)$ \Comment*[r]{Produce the VRF output}
    \If (\Comment*[f]{If meeting difficulty}) {$out < Target$}{
      break \Comment*[r]{Mining successful}
    }
  }
  $\pi \gets \mathsf{VRFProve}(sk, blk)$ \Comment*[r]{Produce the proof}
  \Return{$blk$, $out$, $\pi$} \Comment*[r]{Return block, hash and proof}
\end{algorithm}



\begin{algorithm}[h]
\caption{$\mathsf{Verify}(blk, out, \pi, Target)$}
\label{algo:verify}
\SetAlgoLined\DontPrintSemicolon
$pk \gets blk . txs[0] . scriptPubKey$ \Comment*[r]{Find pubkey in coinbase tx}
$\mathsf{require}(out < Target)$ \Comment*[r]{Hash should meet diff requirement}
\tcc{Here $\mathsf{VRFVerify}(\cdot)$ ensures:\\
1. $out$ is generated by the owner of $sk$\\
2. $out$ is the valid output of $\mathsf{VRFHash}(sk, blk)$}
$\mathsf{require}(\mathsf{VRFVerify}(pk, blk, out, \pi))$ \;
$\dots$ \Comment*[l]{Verify other fields}
$\dots$ \Comment*[l]{Verify transactions}
\end{algorithm}

Cryptocurrency mining consists of two components, namely mining blocks and verifying blocks.
We call the process of mining a block $\mathsf{Work}$, and the process of verifying a block $\mathsf{Verify}$.
Algorithm~\ref{algo:work} and \ref{algo:verify} describe $\mathsf{Work}$ and $\mathsf{Verify}$ of VRF-based mining, respectively.

\textbf{Work.}
Miners run $\mathsf{Work}$ to mine new blocks.
More specifically, a miner - with his private key $sk$ the block template (a complete block without nonce) $t$ - keeps searching for a nonce $n$ that can make the (VRF) hash $out$ of the block $blk$ to meet the difficulty requirement $Target$.
Once finding a valid $n$, the miner produces the proof $\pi$ of $out$, and appends $blk$ (with $n$), $out$ and $\pi$ to the blockchain.

\textbf{Verify.}
Upon incoming blocks, miners run $\mathsf{Verify}$ to verify their validity.
While other verifications are the same as in hash-based mining, $\mathsf{Verify}$ in VRF-based mining should additionally run $\mathsf{VRFVerify}(\cdot)$ to verify 1) whether $out$ is produced by the owner of $sk$, and 2) whether $out$ is a valid output of $\mathsf{VRFHash}(sk, blk)$.

\textbf{Block structure.}
Different from hash-based mining, in VRF-based mining a block should additionally attach $out$ and $\pi$, but no longer need the signature of a block.
Other miners without knowing $sk$ cannot produce $out$, but can use $\pi$ to verify $out$ is generated by someone knowing $sk$.
Through proving the authorship of $out$, $\pi$ also proves the authorship of the block.
Thus, miners only need to sign $out$, but do not need to sign blocks.