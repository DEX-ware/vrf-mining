\section{VRF-based mining}
\label{sec:construction}

% intuitive
Instead of using a hash function, VRF-based mining uses a VRF to produce outputs that satisfy the difficulty requirement.
VRF takes both an input and a secret key to produce an output.
The owner of this secret key can produce a proof proving the ownership of its output.
Thus, to outsource the mining process, the pool operator has to reveal its secret key to miners.
However, with the secret key, any miner in the mining pool can steal all mining rewards.

\begin{algorithm}[]
\caption{$\mathsf{Work}(sk, pk, tpl, T)$.}\label{algo:work}
\SetAlgoLined\DontPrintSemicolon
  \While (\Comment*[f]{Refresh the nonce}) {$nonce += 1$}{
    $blk \gets \mathsf{ConstructBlock}(tpl, nonce)$ \Comment*[r]{Assemble block}
    $out \gets \mathsf{VRFHash}(sk, blk)$ \Comment*[r]{Produce VRF output}
    \If (\Comment*[f]{If meeting difficulty}) {$out < T$}{
      break \Comment*[r]{Mining successful}
    }
  }
  $\pi \gets \mathsf{VRFProve}(sk, blk)$ \Comment*[r]{Produce the proof}
  $B \gets (blk, pk, out, \pi)$ \Comment*[r]{Assemble the complete block}
  \Return{$B$}
\end{algorithm}



\begin{algorithm}[h]
\caption{$\mathsf{Verify}(B, T)$}\label{algo:verify}
\SetAlgoLined\DontPrintSemicolon
  $(blk, pk, out, pi) \gets B$ \Comment*[r]{Disassemble block}
  Require $B$'s coinbase tx is binding to $pk$\\
  $\mathsf{require}(out < T)$ \Comment*[r]{Check if satisfying diff}
  \tcc{Here $\mathsf{VRFVerify}(\cdot)$ ensures:\\
  1. $out$ is generated by the owner of $sk$\\
  2. $out$ is a valid output of $\mathsf{VRFHash}(sk, blk)$}
  $\mathsf{require}(\mathsf{VRFVerify}(pk, blk, out, \pi))$ \;
  $\dots$ \Comment*[l]{Verify other fields}
  $\dots$ \Comment*[l]{Verify transactions}
\end{algorithm}

Cryptocurrency mining consists of two components, namely mining blocks and verifying blocks.
We call the process of mining a block $\mathsf{Work}(\cdot)$, and the process of verifying a block $\mathsf{Verify}(\cdot)$.
Algorithm~\ref{algo:work} and \ref{algo:verify} describe $\mathsf{Work}(\cdot)$ and $\mathsf{Verify}(\cdot)$ of VRF-based mining, respectively.

\textbf{Work.}
In $\mathsf{Work}(\cdot)$, the miner - with secret key $sk$ and block template $tpl$ - keeps searching for a $nonce$ that can make the VRF output $out$ of the block $blk$ to meet the blockchain difficulty $T$.
Once finding a valid $nonce$ that makes $out < T$, the miner produces proof $\pi$, assembles $blk$, $pk$, $out$, $\pi$ to the complete block $B$.
The miner then broadcasts $B$ to the network.

\textbf{Verify.}
Upon a new block $B$, the verifier runs $\mathsf{Verify}(\cdot)$ to verify $B$'s validity.
In addition to verification rules in hash-based mining, $\mathsf{Verify}(\cdot)$ specifies three extra rules.
First, the VRF output $out$ should be smaller than the difficulty parameter $T$.
Second, $B$'s coinbase transaction should be binding to $pk$.
If the transaction's output stores the public key, then it should equal to $pk$.
If the transaction's output stores the address -- which is usually a digest of the public key, then it should equal to the digest of $pk$.
Last, the verifier should run $\mathsf{VRFVerify}(\cdot)$ to check if 1) $out$ is produced by the owner of $pk$, and 2) $out$ is a valid VRF output of $blk$.