\section{Practicality of VRF-based mining}
\label{sec:practicality}

In this section, we experimentally show that VRF-based mining is easy to implement and introduces little overhead.
Our experiment is twofold.
First, we compare the performance of VRFs with three other hash functions used for cryptocurrency mining, namely SHA256D used in Bitcoin, Scrypt used in Litecoin and CryptoNight used in Monero.
The comparison shows that VRF can be much faster than Ethereum and CryptoNight.
Second, we measure the runtime of each step ($H_1(\cdot)$, point multiplication and $H_2(\cdot)$) of $\mathsf{VRFHash}$.
The result shows that the elliptic curve scalar multiplication dominates $\mathsf{VRFHash}$'s runtime, which can be optimised in the future.

\subsection{Experimental setting}

We implement the standardised EC-VRF in Algorithm~\ref{algo:standard-ecvrf} using Go programming language.
In particular, we use Ed25519~\cite{bernstein2012high} as the underlying elliptic curve, Elligator~\cite{bernstein2013elligator} as $H_1(\cdot)$, SHA-3 as the $H_3(\cdot)$ hash function.
Ed25519, SHA-3 and the encoding of points on Ed25519 are supported by Go's standard library.
We do not apply any optimisation on the EC-VRF implementation.
We use open-source implementations basing on their popularity on \url{https://github.com/} for SHA256D~\footnote{\url{https://github.com/seehuhn/sha256d}}, Scrypt~\footnote{\url{https://github.com/elithrar/simple-scrypt}}, and CryptoNight~\footnote{\url{https://github.com/Equim-chan/cryptonight}}.

All experiments run on a MacBook Pro with a 2.2 GHz Intel Core i7 Processor, a 16 GB DDR4 RAM and 256 SSD storage disk.
For each group of experiment, we run an algorithm for ten times, then take the average data as the experimental results.




\subsection{Comparison between VRF and other mining algorithms}

\begin{figure}[htp]
    \centering
    \includegraphics[width=.7\linewidth]{figs/runtime-comparison.eps}
    \caption{Comparing the runtime of VRF and other mining algorithms.}
    \label{fig:runtime-comparison}
\end{figure}

First, we compare the performance of VRF with other mining algorithms.
Figure~\ref{fig:runtime-comparison} shows the runtime of VRF and other algorithms.
First, SHA256D is much faster than other algorithms.
This is because SHA256D is simply executing SHA256 hashing twice, which is quite fast.
This is not a concern, because,
as aforementioned, if we want the mining being ASIC-resistant, we need to make $H_{1}(\cdot)$ or $H_{2}$ memory-hard; but SHA256D, however, is not memory-hard.
Second, $\mathsf{VRFVerify}$ is slightly slower than $\mathsf{VRFProve}$, and $\mathsf{VRFProve}$ is slightly slower than $\mathsf{VRFHash}$.
Last, although without optimisation, all functions of VRF are much faster than Scrypt and CryptoNight.

This means that VRF is easy to implement and introduces little overhead, so suitable for cryptocurrency mining.



\subsection{Runtime breakdown of VRF}

\begin{figure}[htp]
    \centering
    \includegraphics[width=.7\linewidth]{figs/runtime-breakdown.eps}
    \caption{Runtime breakdown of $\mathsf{VRFHash}$.}
    \label{fig:runtime-breakdown}
\end{figure}

Second, we profile $\mathsf{VRFHash}$ by evaluating its runtime of each step.
Figure~\ref{fig:runtime-breakdown} shows that, the elliptic curve scalar multiplication $\gamma \gets h^{sk}$ takes 88\% of $\mathsf{VRFHash}$'s running time.
This is as expected, as we use SHA-3 as the hash function for $H_1(\cdot)$ and $H_2(\cdot)$, and SHA-3 is designed to be fast.
Meanwhile, we calculate the elliptic curve scalar multiplication using the trivial double-and-add method without any optimisation, thus is much slower than $H_1(\cdot)$ and $H_2(\cdot)$.
Even so, $\mathsf{VRFHash}$ is still much faster than Scrypt and CryptoNight.
This further proves that VRFs introduce little overhead.