\section{Preliminaries}

\subsection{Cryptocurrency mining}


A miner mines on a blockchain with Nakamoto consensus by solving PoW puzzles.
The PoW puzzle is usually constructed using cryptographic hash functions, and works as follows.
% how mining works
First, a miner constructs a block template, which consists of transactions to include, hash of the last block, and other block metadata, except the nonce.
Second, the miner should find a nonce which makes the hash of the block to satisfy a difficulty parameter.
Once the miner find a valid nonce, he can append this block to the blockchain.
% how diff works
As hash functions are one-way, miners cannot calculate nonces from hashes.
Instead, miners can only repetitively hash different nonces until finding a hash satisfying the difficulty parameter.
The difficulty is parametrised by limiting the interval of hashes.
For example, Bitcoin controls the difficulty of finding a nonce by specifying the number of leading zeros of hashes.





\subsection{Mining pools}

In a mining pool, the pool operator outsources the mining process by allowing miners to find nonces for him.
% distribute
More specifically, the pool operator distributes his block template as well as a ``share difficulty'' to each miner.
The share difficulty is much lower than the difficulty of the blockchain.
% submit
Miners then keep finding nonces to make the block hash to satisfy the share difficulty, and submitting valid nonces to the pool operator.
% reward
As nonces satisfying the blockchain difficulty must satisfy the share difficulty, miners can filter submitted nonces to obtain nonces that can produce blocks.
After a time period (say 24 hours), the pool operator calculates the number of shares submitted by each miner, and distributes the mining reward to each miner according to their submitted shares.
% why stable
As finding a valid share is much easier than finding a valid block, calculating the mining power of a miner using shares is more fine-grained than using blocks.
In this way, each miner is rewarded in a more fine-grained way, so more stably.




\subsection{Verifiable random functions}

Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
In addition to the input string, VRF involves a pair of a secret key and a public key.
Given an input string and a secret key, one can compute a hash.
Anyone knowing the associated public key can verify the correctness of the hash, and can also verify the hash is generated by the owner of the secret key.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $(sk, pk) \gets \mathsf{VRFKeyGen}(1^{\lambda})$: on input a security parameter $1^{\lambda}$, outputs the secret/public key pair $(sk, pk)$.
    \item $\beta \gets \mathsf{VRFHash}(sk, \alpha)$: on input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length hash $\beta$.
    \item $\pi \gets \mathsf{VRFProve}(sk, \alpha)$: on input $sk$ and $\alpha$, outputs the proof $\pi$ for $\beta$.
    \item $\{0, 1\} \gets \mathsf{VRFVerify}(pk, \alpha, \beta, \pi)$: on input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result 0 or 1.
\end{itemize}

% refer https://tools.ietf.org/pdf/draft-goldbe-vrf-01.pdf
VRFs should preserve three security properties, including \textbf{Uniqueness}, \textbf{Collision Resistance}, \textbf{Pseudorandomness}. Informally,

\begin{description}
    \item[Uniqueness] Given any public VRF key and any input, there is a unique valid output.
    \item[Collision Resistance] Finding two different inputs that have the same output is computationally hard.
    \item[Pseudorandomness] Without knowing the corresponding proof, distinguishing a VRF output from a random string is computationally hard.
\end{description}


Here we describe the Elliptic-curve-based VRF (EC-VRF) construction standardised in draft-goldbe-vrf~\cite{goldberg2017draft}.

% \noindent\fbox{
%     \parbox{\textwidth}{

\begin{figure}[]
    \begin{mdframed}

        Let $G$ be a cyclic group of prime order $q$ with generator $g$.\\
        Let $H_1(\cdot)$ be a hash function mapping an arbitrary-length string into an element in $G$.\\
        Let $H_2(\cdot)$ be a hash function mapping an element in $G$ into a fixed-length string.\\
        Let $H_3(\cdot)$ be a hash function mapping an arbitrary-length string into a fixed-length string.\\

        $(sk, pk) \gets \mathsf{VRFKeyGen}(1^{\lambda})$
        \begin{enumerate}
            \item $sk = \mathsf{random}(\interval{0}{q-1})$
            \item $pk = g^{sk}$
        \end{enumerate}

        $\beta \gets \mathsf{VRFHash}(sk, \alpha)$
        \begin{enumerate}
            \item $h = H_{1}(\alpha)$
            \item $\gamma = h^{sk}$
            \item $\beta = H_{2}(\gamma)$
        \end{enumerate}

        $\pi \gets \mathsf{VRFProve}(sk, \alpha)$
        \begin{enumerate}
            \item $h = H_{1}(\alpha)$
            \item $\gamma = h^{sk}$
            \item $k = \mathsf{random}(\interval{0}{q-1})$
            \item $c = H_{3}(g, h, pk, h^{sk}, g^{k}, h^{k})$
            \item $s = k - c \cdot sk \pmod{q}$
            \item $\pi = (\gamma, c, s)$
        \end{enumerate}

        $\{0, 1\} \gets \mathsf{VRFVerify}(pk, \alpha, \beta, \pi)$
        \begin{enumerate}
            \item $u = pk^{c} \cdot g^{s}$
            \item $h = H_{1}(\alpha)$
            \item check if $\gamma \stackrel{?}{\in} G$
            \item $v = \gamma^{c} \cdot h^{s}$
            \item check if $c \stackrel{?}{=} H_{3}(g, h, pk, \gamma, u, v)$
        \end{enumerate}

    \end{mdframed}

    \label{fig:standard-ecvrf}
    \caption{The construction of Elliptic-curve-based VRF standardised in draft-goldbe-vrf~\cite{goldberg2017draft}.}
\end{figure}
