\section{Preliminaries}

\subsection{Cryptocurrency mining and mining pools}


A miner mines on a blockchain with Nakamoto consensus by solving PoW puzzles.
The PoW puzzle is usually constructed using cryptographic hash functions, and works as follows.
% how mining works
First, a miner constructs a block template, which consists of transactions to include, hash of the last block, and other block metadata, except the nonce.
Second, the miner should find a nonce which makes the hash of the block to satisfy a difficulty parameter.
Once the miner find a valid nonce, he can append this block to the blockchain.
% how diff works
As hash functions are one-way, miners cannot calculate nonces from hashes.
Instead, miners can only repetitively hash different nonces until finding a hash satisfying the difficulty parameter.
The difficulty is parametrised by limiting the interval of hashes.
For example, Bitcoin controls the difficulty of finding a nonce by specifying the number of leading zeros of hashes.



In a mining pool, the pool operator outsources the mining process by allowing miners to find nonces for him.
% distribute
More specifically, the pool operator distributes his block template as well as a ``share difficulty'' to each miner.
The share difficulty is much lower than the difficulty of the blockchain.
% submit
Miners then keep finding nonces to make the block hash to satisfy the share difficulty, and submitting valid nonces to the pool operator.
% reward
As nonces satisfying the blockchain difficulty must satisfy the share difficulty, miners can filter submitted nonces to obtain nonces that can produce blocks.
After a time period (say 24 hours), the pool operator calculates the number of shares submitted by each miner, and distributes the mining reward to each miner according to their submitted shares.
% why stable
As finding a valid share is much easier than finding a valid block, calculating the mining power of a miner using shares is more fine-grained than using blocks.
In this way, each miner is rewarded in a more fine-grained way, so more stably.




\subsection{Verifiable random functions}

Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
It involves a pair of a secret key and a public key.
Only the owner of the secret key can compute the hash, while anyone having the public key can verify the hash.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $(sk, pk) \gets \mathsf{VRFKeyGen}(1^{\lambda})$: on input a security parameter $1^{\lambda}$, outputs the secret/public key pair $(sk, pk)$.
    \item $\beta \gets \mathsf{VRFHash}(sk, \alpha)$: on input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length hash $\beta$.
    \item $\pi \gets \mathsf{VRFProve}(sk, \alpha)$: on input $sk$ and $\alpha$, outputs the proof $\pi$ for $\beta$.
    \item $\{0, 1\} \gets \mathsf{VRFVerify}(pk, \alpha, \beta, \pi)$: on input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result 0 or 1.
\end{itemize}

% refer https://tools.ietf.org/pdf/draft-goldbe-vrf-01.pdf
VRFs should preserve three security properties, including \textbf{Uniqueness}, \textbf{Collision Resistance}, \textbf{Pseudorandomness}. Informally, 

\begin{description}
    \item[Uniqueness] Given any public VRF key and any input, there is a unique valid output.
    \item[Collision Resistance] Finding two different inputs that have the same output is computationally hard.
    \item[Pseudorandomness] Without knowing the corresponding proof, distinguishing a VRF output from a random string is computationally hard.
\end{description}

