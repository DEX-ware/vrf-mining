\section{Preliminaries}
\label{sec:preliminaries}

\subsection{PoW-based consensus and mining}
Miners participate in PoW-based consensus by \emph{mining}, which works as follows.
% how mining works
Given the blockchain's latest view, the miner creates a block template $t$, which consists of transactions to include, hash of the last block, and other metadata.
The miner then tries to solve a PoW puzzle that, the miner should find a nonce $n$ such that $H(t || n)$ is smaller than a difficulty parameter $T$.
Note that $H(\cdot)$ is a one-way hash function, and the miner can only try different nonces until finding a valid one.
Once the miner find a valid nonce, he can assemble this nonce and $t$ to a block, and append this block to the blockchain.
The miner will get some coins as the reward of mining.
% diff adjustment
By adaptively adjusting $T$, the rate of new blocks remains stable.
If miners mine too many blocks in a previous time period, the protocol will increase $T$ so that miners will mine slower.
Otherwise, the protocol will decrease $T$.

\subsection{Mining pools}
As the rate of new blocks is limited, the mining reward of miners is highly volatile, especially for miners with less powerful hardware.
To stabilise mining reward, miners usually participate in mining pools.
Mining pools enable miners to mine collaboratively and distribute reward in a fine-grained way.
A mining pool usually relies on a centralised pool operator.
All miners mine in the name of the pool operator, and the pool operator distributes rewards in proportion to miners' contribution.

Concretely, a mining pool works as follows.
First, a pool operator specifies the pool difficulty $PT$ --- a difficulty lower than the blockchain network --- and a search interval $[n_1, n_m]$ of nonces.
Then, the pool operator sends the block template $t$, $PT$, $n_1$ and $n_m$ to the miner, and the miner starts to find a nonce in $[n_1, n_m]$ which satisfies $PT$.
Once finding a valid nonce $n_k$, the miner sends $n_k$ back to the pool operator.
The pool operator then verifies whether $n_k$ produces a hash satisfying $PT$, and records the miner's contribution (a.k.a. a share) if valid.
After a time period (say 24 hours), the pool operator calculates the total contribution of each miner, and distributes the mining reward to miners according to their submitted shares.
% why stable
As $PT$ is easier to solve, calculating the mining power of a miner using shares is more fine-grained than using blocks.
In this way, each miner is rewarded in a more fine-grained way, so more stably.


\subsection{Verifiable random functions}

Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
In addition to the input string, VRF requires a pair of a secret key and a public key.
Given an input string and a secret key, one can compute an output.
Anyone knowing the associated public key can verify the correctness of the output, and can also verify the output is generated by the owner of the secret key.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $\mathsf{VRFKeyGen}(1^{\lambda}) \to (sk, pk)$: On input security parameter $1^{\lambda}$, outputs a secret/public key pair $(sk, pk)$.
    \item $\mathsf{VRFHash}(sk, \alpha) \to \beta $: On input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length output $\beta$.
    \item $\mathsf{VRFProve}(sk, \alpha) \to \pi$: On input $sk$ and $\alpha$, outputs the proof of correctness $\pi$ for $\beta$.
    \item $\mathsf{VRFVerify}(pk, \alpha, \beta, \pi) \to \{True, False\}$: On input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result $True$ or $False$.
\end{itemize}

% refer https://tools.ietf.org/pdf/draft-goldbe-vrf-01.pdf
Informally, VRF should preserve the following three security properties~\cite{goldberg2017draft}:

\begin{itemize}
    \item \emph{Uniqueness}: Given a secret key $sk$ and an input $\alpha$, $\mathsf{VRFHash}(sk, \alpha)$ produces a unique valid output.
    \item \emph{Collision Resistance}: It is computationally hard to find two inputs $\alpha$ and $\alpha'$ that $\mathsf{VRFHash}(sk, \alpha) = \mathsf{VRFHash}(sk, \alpha')$.
    \item \emph{Pseudorandomness}: It is computationally hard to distinguish the output of $\mathsf{VRFHash}(sk, \alpha)$ from a random string if not knowing the corresponding public key $pk$ and proof $\pi$.
\end{itemize}

Algorithm~\ref{algo:standard-ecvrf} in Appendix~\ref{sec:ec-vrf} describes the Elliptic-curve-based VRF (EC-VRF) construction standardised in draft-goldbe-vrf~\cite{goldberg2017draft}.








% \begin{figure}[]
%     \centering
%     \begin{msc}{}
%         \setlength{\envinstdist}{2.5cm}

%         \setlength{\instdist}{3.5cm}
%         \setlength{\instwidth}{1.5cm}
        
%         \declinst{pool}{}{Pool}
%         \declinst{miner}{}{Miner}

%         \action*{\parbox{4.5cm}{
%             Get block template $t$\\
%             Get pool mining difficulty $PT$\\
%             Get nonce interval $[n_1, n_m]$
%         }}{pool}

%         \nextlevel[4]
%         \mess{$n_1, n_m, t, PT$}{pool}{miner}

%         \nextlevel
%         \action*{\parbox{3.5cm}{
%             Find an $n_k \in [n_1, n_m]$ \\
%             that $H(t||n_k) < PT$ 
%         }}{miner}

%         \nextlevel[3]
%         \mess{$n_k$}{miner}{pool}

%         \nextlevel
%         \action*{\parbox{3cm}{
%             (Optional) Check if \\
%             $H(t||n_k) < PT$
%         }}{pool}

%         \nextlevel[2]
%     \end{msc}
%     \caption{Outsourcing in hash-based mining.}
%     \label{fig:outsource-original}
% \end{figure}