\section{Preliminaries}
\label{sec:preliminaries}

\subsection{Cryptocurrency mining}


A miner mines on a blockchain with PoW-based consensus by solving crypto puzzles.
The crypto puzzle is usually constructed using cryptographic hash functions, and works as follows.
% how mining works
First, a miner constructs a block template $t$, which consists of transactions to include, hash of the last block, and other block metadata.
Second, the miner should find a nonce $n$ such that the hash of $t || n$ is smaller than a difficulty parameter.
Once the miner find a valid nonce, he can append this block to the blockchain.
% how diff works
To solve a PoW puzzle, miners iteratively computes hash values of different nonces until finding a hash satisfying the difficulty parameter.
The difficulty can be parametrised by limiting the interval of hashes.
For example, Bitcoin controls the difficulty of finding a nonce by specifying the number of leading zeros of hashes.





\subsection{Mining pools}

% \begin{figure}[]
%     \centering
%     \begin{msc}{}
%         \setlength{\envinstdist}{2.5cm}

%         \setlength{\instdist}{3.5cm}
%         \setlength{\instwidth}{1.5cm}
        
%         \declinst{pool}{}{Pool}
%         \declinst{miner}{}{Miner}

%         \action*{\parbox{4.5cm}{
%             Get block template $t$\\
%             Get pool mining difficulty $PT$\\
%             Get nonce interval $[n_1, n_m]$
%         }}{pool}

%         \nextlevel[4]
%         \mess{$n_1, n_m, t, PT$}{pool}{miner}

%         \nextlevel
%         \action*{\parbox{3.5cm}{
%             Find an $n_k \in [n_1, n_m]$ \\
%             that $H(t||n_k) < PT$ 
%         }}{miner}

%         \nextlevel[3]
%         \mess{$n_k$}{miner}{pool}

%         \nextlevel
%         \action*{\parbox{3cm}{
%             (Optional) Check if \\
%             $H(t||n_k) < PT$
%         }}{pool}

%         \nextlevel[2]
%     \end{msc}
%     \caption{Outsourcing in hash-based mining.}
%     \label{fig:outsource-original}
% \end{figure}

In a mining pool, the pool operator outsources the mining process by allowing miners to find nonces for him.
First, a pool operator specifies the pool difficulty $PT$ - a difficulty lower than the blockchain network - and a search interval $[n_1, n_m]$ of nonces.
Then, the pool operator sends the block template $t$, $PT$, $n_1$ and $n_m$ to the miner, and the miner starts to find a nonce in $[n_1, n_m]$ which satisfies $PT$.
Once finding a valid nonce $n_k$, the miner sends $n_k$ back to the pool operator.
The pool operator then verifies whether $n_k$ produces a hash satisfying $PT$, and records the miner's contribution (a.k.a. a share) if valid.
After a time period (say 24 hours), the pool operator calculates the total contribution of each miner, and distributes the mining reward to miners according to their submitted shares.
% why stable
As $PT$ is easier to solve, calculating the mining power of a miner using shares is more fine-grained than using blocks.
In this way, each miner is rewarded in a more fine-grained way, so more stably.


\subsection{Verifiable random functions}

Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
In addition to the input string, VRF involves a pair of a secret key and a public key.
Given an input string and a secret key, one can compute a hash.
Anyone knowing the associated public key can verify the correctness of the hash, and can also verify the hash is generated by the owner of the secret key.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $\mathsf{VRFKeyGen}(1^{\lambda}) \to (sk, pk)$: On input a security parameter $1^{\lambda}$, outputs the secret/public key pair $(sk, pk)$.
    \item $\mathsf{VRFHash}(sk, \alpha) \to \beta $: On input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length hash $\beta$.
    \item $\mathsf{VRFProve}(sk, \alpha) \to \pi$: On input $sk$ and $\alpha$, outputs the proof $\pi$ for $\beta$.
    \item $\mathsf{VRFVerify}(pk, \alpha, \beta, \pi) \to \{True, False\}$: On input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result $True$ or $False$.
\end{itemize}

% refer https://tools.ietf.org/pdf/draft-goldbe-vrf-01.pdf
A VRF should preserve the following three security properties~\cite{goldberg2017draft}:

\begin{itemize}
    \item \textbf{Uniqueness}: Given a secret key $sk$ and an input $\alpha$, $\mathsf{VRFHash}(sk, \alpha)$ produces a unique valid output.
    \item \textbf{Collision Resistance}: It is computationally hard to find two inputs $\alpha$ and $\alpha'$ that $\mathsf{VRFHash}(sk, \alpha) = \mathsf{VRFHash}(sk, \alpha')$.
    \item \textbf{Pseudorandomness}: It is computationally hard to distinguish the output of $\mathsf{VRFHash}(sk, \alpha)$ from a random string if not knowing the corresponding public key $pk$ and proof $\pi$.
\end{itemize}

Algorithm~\ref{algo:standard-ecvrf} in Appendix~\ref{sec:ec-vrf} describes the Elliptic-curve-based VRF (EC-VRF) construction standardised in draft-goldbe-vrf~\cite{goldberg2017draft}.
