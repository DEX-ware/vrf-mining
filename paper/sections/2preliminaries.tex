\section{Preliminaries}

\subsection{Cryptocurrency mining}


A miner mines on a blockchain with Nakamoto consensus by solving PoW puzzles.
The PoW puzzle is usually constructed using cryptographic hash functions, and works as follows.
% how mining works
First, a miner constructs a block template, which consists of transactions to include, hash of the last block, and other block metadata, except the nonce.
Second, the miner should find a nonce which makes the hash of the block to satisfy a difficulty parameter.
Once the miner find a valid nonce, he can append this block to the blockchain.
% how diff works
As hash functions are one-way, miners cannot calculate nonces from hashes.
Instead, miners can only repetitively hash different nonces until finding a hash satisfying the difficulty parameter.
The difficulty is parametrised by limiting the interval of hashes.
For example, Bitcoin controls the difficulty of finding a nonce by specifying the number of leading zeros of hashes.





\subsection{Mining pools}

In a mining pool, the pool operator outsources the mining process by allowing miners to find nonces for him.
% distribute
More specifically, the pool operator distributes his block template as well as a ``share difficulty'' to each miner.
The share difficulty is much lower than the difficulty of the blockchain.
% submit
Miners then keep finding nonces to make the block hash to satisfy the share difficulty, and submitting valid nonces to the pool operator.
% reward
As nonces satisfying the blockchain difficulty must satisfy the share difficulty, miners can filter submitted nonces to obtain nonces that can produce blocks.
After a time period (say 24 hours), the pool operator calculates the number of shares submitted by each miner, and distributes the mining reward to each miner according to their submitted shares.
% why stable
As finding a valid share is much easier than finding a valid block, calculating the mining power of a miner using shares is more fine-grained than using blocks.
In this way, each miner is rewarded in a more fine-grained way, so more stably.




\subsection{Verifiable random functions}

Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
In addition to the input string, VRF involves a pair of a secret key and a public key.
Given an input string and a secret key, one can compute a hash.
Anyone knowing the associated public key can verify the correctness of the hash, and can also verify the hash is generated by the owner of the secret key.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $(sk, pk) \gets \mathsf{VRFKeyGen}(1^{\lambda})$: on input a security parameter $1^{\lambda}$, outputs the secret/public key pair $(sk, pk)$.
    \item $\beta \gets \mathsf{VRFHash}(sk, \alpha)$: on input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length hash $\beta$.
    \item $\pi \gets \mathsf{VRFProve}(sk, \alpha)$: on input $sk$ and $\alpha$, outputs the proof $\pi$ for $\beta$.
    \item $\{0, 1\} \gets \mathsf{VRFVerify}(pk, \alpha, \beta, \pi)$: on input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result 0 or 1.
\end{itemize}

% refer https://tools.ietf.org/pdf/draft-goldbe-vrf-01.pdf
VRFs should preserve the following three security properties~\cite{goldberg2017draft}:

\begin{description}
    \item[Uniqueness] Given any public VRF key and any input, there is a unique valid output.
    \item[Collision Resistance] Finding two different inputs that have the same output is computationally hard.
    \item[Pseudorandomness] Without knowing the corresponding proof, distinguishing a VRF output from a random string is computationally hard.
\end{description}


Algorithm~\ref{algo:standard-ecvrf} describes the Elliptic-curve-based VRF (EC-VRF) construction standardised in draft-goldbe-vrf~\cite{goldberg2017draft}.

\begin{algorithm}[]
    \SetAlgoLined\DontPrintSemicolon
    \SetKwFunction{VRFKeyGen}{$(sk, pk) \gets \mathsf{VRFKeyGen}$}
    \SetKwFunction{VRFHash}{$\beta \gets \mathsf{VRFHash}$}
    \SetKwFunction{VRFProve}{$\pi \gets \mathsf{VRFProve}$}
    \SetKwFunction{VRFVerify}{$\{0, 1\} \gets \mathsf{VRFVerify}$}
    \SetKwProg{myalg}{Algorithm}{:}{}

    Preliminaries:
    \begin{itemize}
        \item $G$ is a cyclic group of prime order $q$ with generator $g$.
        \item $H_1(\cdot)$ hashes an arbitrary-length string into an element in $G$.
        \item $H_2(\cdot)$ hashes an element in $G$ into a fixed-length string.
        \item $H_3(\cdot)$ hashes an arbitrary-length string into a fixed-length string.
        \item $\mathsf{random}([x, y])$ uniformly and randomly picks a number in $\interval{x}{y}$.
    \end{itemize}

    \myalg{\VRFKeyGen{$1^{\lambda}$}}{
        $sk = \mathsf{random}(\interval{0}{q-1})$\;
        $pk = g^{sk}$\;
        \Return{$(sk, pk)$} \;}{}

    \myalg{\VRFHash{$sk, \alpha$}}{
        $h = H_{1}(\alpha)$\;
        $\gamma = h^{sk}$\;
        $\beta = H_{2}(\gamma)$\;
        \Return{$\beta$}\;}{}

    \myalg{\VRFProve{$sk, \alpha$}}{
        $h = H_{1}(\alpha)$\;
        $\gamma = h^{sk}$\;
        $k = \mathsf{random}(\interval{0}{q-1})$\;
        $c = H_{3}(g, h, pk, h^{sk}, g^{k}, h^{k})$\;
        $s = k - c \cdot sk \pmod{q}$\;
        $\pi = (\gamma, c, s)$\;
        \Return{$\pi$}\;}{}

    \myalg{\VRFVerify{$pk, \alpha, \beta, \pi$}}{
        $u = pk^{c} \cdot g^{s}$\;
        $h = H_{1}(\alpha)$\;
        \If{$\gamma \notin G$}{
            \Return{$0$}\;
        }
        $v = \gamma^{c} \cdot h^{s}$\;
        \If{$c \neq H_{3}(g, h, pk, \gamma, u, v)$}{
            \Return{$0$}\;
        }
        \Return{$1$}\;}{}

    \label{algo:standard-ecvrf}
    \caption{The Elliptic-curve-based VRF (EC-VRF) construction standardised in draft-goldbe-vrf~\cite{goldberg2017draft}.}
\end{algorithm}
