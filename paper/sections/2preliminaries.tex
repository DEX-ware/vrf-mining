\section{Preliminaries}

\subsection{Cryptocurrency mining and mining pools}

\TODO{rephrase due to similarity to ``SoK: Research Perspectives and Challenges for Bitcoin and Cryptocurrencies''}


In cryptocurrency mining, miners search for the solution to a computational puzzle.
Specifically, the puzzle is to find a (partial) pre-image for a cryptographic hash function, of which output is less than a target value beginning with several consecutive zero bits.
The hash function maps a list of transaction, the hash of the previous block, a timestamp, an nonce and other information, to a result value.
As the hash result is unpredictable and uniformly distributed, the probability of the hash result lies among the desired interval is inversely proportional to the number of leading zero.

The more computation power the miner possesses, the more rounds of hash he can run during a time unit, and the more likely he can find the solution. The first miner who finds the solution and announces it, wins the competition and gets rewarded.

\RH{In addition, we should talk how mining pool works as well. In particular,
1. architecture (pool operator, miner)
2. protocol (miner submits share, pool operator verifies share and distribute reward)
3. why more stable reward? (share diff is much smaller)}



\subsection{Verifiable random functions}

Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
It involves a pair of a secret key and a public key.
Only the owner of the secret key can compute the hash, while anyone having the public key can verify the hash.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $(sk, pk) \gets \mathsf{VRFKeyGen}(1^{\lambda})$: on input a security parameter $1^{\lambda}$, outputs the secret/public key pair $(sk, pk)$.
    \item $\beta \gets \mathsf{VRFHash}(sk, \alpha)$: on input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length hash $\beta$.
    \item $\pi \gets \mathsf{VRFProve}(sk, \alpha)$: on input $sk$ and $\alpha$, outputs the proof $\pi$ for $\beta$.
    \item $\{0, 1\} \gets \mathsf{VRFVerify}(pk, \alpha, \beta, \pi)$: on input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result 0 or 1.
\end{itemize}

% refer https://tools.ietf.org/pdf/draft-goldbe-vrf-01.pdf
VRFs should preserve three security properties, including \textbf{Uniqueness}, \textbf{Collision Resistance}, \textbf{Pseudorandomness}. Informally, 

\begin{itemize}
    \item \textbf{Uniqueness}: Given any public VRF key and any input, there is a unique valid output.
    \item \textbf{Collision Resistance}: Finding two different inputs that have the same output is computationally hard.
    \item \textbf{Pseudorandomness}: Without knowing the corresponding proof, distinguishing a VRF output from a random string is computationally hard.
\end{itemize}

