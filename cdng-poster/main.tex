%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% a0poster Portrait Poster
% LaTeX Template
% Version 1.0 (22/06/13)
%
% The a0poster class was created by:
% Gerlinde Kettl and Matthias Weiser (tex@kettl.de)
% 
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[a0,portrait]{a0poster}

\usepackage{multicol} % This is so we can have multiple columns of text side-by-side
\columnsep=100pt % This is the amount of white space between the columns in the poster
\columnseprule=3pt % This is the thickness of the black line between the columns in the poster

\usepackage[svgnames]{xcolor} % Specify colors by their 'svgnames', for a full list of all colors available see here: http://www.latextemplates.com/svgnames-colors

\usepackage{times} % Use the times font
%\usepackage{palatino} % Uncomment to use the Palatino font

\usepackage{graphicx} % Required for including images
\graphicspath{{figures/}} % Location of the graphics files
\usepackage{booktabs} % Top and bottom rules for table
\usepackage[font=small,labelfont=bf]{caption} % Required for specifying captions to tables and figures
\usepackage{amsfonts, amsmath, amsthm, amssymb} % For math fonts, symbols and environments
\usepackage{wrapfig} % Allows wrapping text around tables and figures

\usepackage[ruled,vlined]{algorithm2e}
\usepackage{algpseudocode}

% blue comment
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
% blue triangle
\SetKwComment{Comment}{\color{blue} $\triangleright$\ }{}


\begin{document}

%----------------------------------------------------------------------------------------
%	POSTER HEADER 
%----------------------------------------------------------------------------------------

% The header is divided into two boxes:
% The first is 75% wide and houses the title, subtitle, names, university/organization and contact information
% The second is 25% wide and houses a logo for your university/organization or a photo of you
% The widths of these boxes can be easily edited to accommodate your content as you see fit

\begin{minipage}[b]{0.75\linewidth}
    \veryHuge \color{NavyBlue} \textbf{VRF-based mining} \color{Black}\\ % Title
    % \Huge\textit{An Exploration of Complexity}\\[2cm] % Subtitle
    \huge \textbf{Runchao Han, Haoyu Lin and Jiangshan Yu}\\[0.5cm] % Author(s)
    \huge Monash University and CSIRO-Data61\\[0.4cm] % University/organization
    \Large \texttt{runchao.han@monash.edu}\\
\end{minipage}
%
\begin{minipage}[b]{0.25\linewidth}
    \includegraphics[width=20cm]{data61-logo.png}\\
\end{minipage}

\vspace{1cm} % A bit of extra whitespace between the header and poster content

%----------------------------------------------------------------------------------------

\begin{multicols}{2} % This is how many columns your poster will be broken into, a portrait poster is generally split into 2 columns

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

\color{Navy} % Navy color for the abstract

\begin{abstract}
    In this paper, we describe VRF-based mining, a simple and effective way of making pooled mining impossible.
    Instead of using hash functions, VRF-based mining uses Verifiable Random Functions (VRFs) for Proof-of-work (PoW)-based consensus.
    As VRF binds the authorship with hashes, a pool operator should reveal his private key to outsource the mining process to miners, and miners can easily steal cryptocurrency in the pool operator's wallet anonymously.

    In addition, we informally revisit the definition of non-outsourceability in existing research, and show VRF-based mining achieves stronger non-outsourceability than all existing proposals.
    Moreover, we describe how to instantiate VRFs for VRF-based mining.
    Last, we discuss potential problems of having no mining pools, and how to address them.
\end{abstract}

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

\color{SaddleBrown} % SaddleBrown color for the introduction

\section*{Introduction}

In this work, we introduce \textit{VRF-based mining}, a novel idea of using Verifiable Random Functions (VRFs) rather than hash functions for mining in PoW-based consensus.
With VRF, a miner should use his private key to mine blocks, so a pool operator should reveal his private key in order to outsource the mining process to miners.
In this way, no one can outsource the mining process, otherwise any miner can steal all cryptocurrency in his wallet anonymously.

Our contributions are as follows:

\begin{description}
    \item [VRF-based mining] We propose the idea of VRF-based mining, and describe its detailed construction. The construction is surprisingly straightforward: we replace the hash function in PoW-based consensus with a VRF, and a block in the blockchain should contain the VRF hash and its proof, but does not need to contain the digital signature. Verifying the VRF hash can prove both the correctness of the hash and the authorship of the block in the same time.
    \item [Revisiting non-outsourceable cryptocurrency mining] We revisit the definition of non-outsourceability of Miller et al.~\cite{miller2015nonoutsourceable}. In particular, we show non-outsourceability consists of punishing pool operators and the unaccountability of punishing. We then show how VRF-based mining achieves stronger punishment of outsourcing than non-outsourceable scratch-off puzzle of Miller et al.~\cite{miller2015nonoutsourceable}.
    \item [Instantiating VRFs for VRF-based mining] We discuss how to instantiate VRFs for VRF-based mining. In particular, we show a VRF has four tweakable components, namely the elliptic curve and two hash functions between strings and elliptic curve elements, and a normal hash function. Then, we discuss concerns how to choose them for VRF-based mining purpose.
    \item [Problems and solutions of having no mining pools] We discuss two problems of having no mining pools, namely the high mining reward variance and the high orphan block rate. We then discuss how to address them without mining pools.
\end{description}




\color{DarkSlateGray} % DarkSlateGray color for the rest of the content

\section*{Verifiable random functions}
Verifiable Random Function (VRF)~\cite{micali1999verifiable} is a public-key version of cryptographic hash function.
In addition to the input string, VRF involves a pair of a secret key and a public key.
Given an input string and a secret key, one can compute a hash.
Anyone knowing the associated public key can verify the correctness of the hash, and can also verify the hash is generated by the owner of the secret key.
Formally, a VRF consists of four algorithms: $\mathsf{VRFKeyGen}$, $\mathsf{VRFHash}$, $\mathsf{VRFProve}$ and $\mathsf{VRFVerify}$.

\begin{itemize}
    \item $(sk, pk) \gets \mathsf{VRFKeyGen}(1^{\lambda})$: on input a security parameter $1^{\lambda}$, outputs the secret/public key pair $(sk, pk)$.
    \item $\beta \gets \mathsf{VRFHash}(sk, \alpha)$: on input $sk$ and an arbitrary-length string $\alpha$, outputs a fixed-length hash $\beta$.
    \item $\pi \gets \mathsf{VRFProve}(sk, \alpha)$: on input $sk$ and $\alpha$, outputs the proof $\pi$ for $\beta$.
    \item $\{0, 1\} \gets \mathsf{VRFVerify}(pk, \alpha, \beta, \pi)$: on input $pk$, $\alpha$, $\beta$, $\pi$, outputs the verification result 0 or 1.
\end{itemize}

% refer https://tools.ietf.org/pdf/draft-goldbe-vrf-01.pdf
A VRF should preserve the following three security properties~\cite{goldberg2017draft}:

\begin{description}
    \item[Uniqueness] Given a secret key $sk$ and an input $\alpha$, $\mathsf{VRFHash}(sk, \alpha)$ produces a unique valid output.
    \item[Collision Resistance] It is computationally hard to find two inputs $\alpha$ and $\alpha'$ that $\mathsf{VRFHash}(sk, \alpha) = \mathsf{VRFHash}(sk, \alpha')$.
    \item[Pseudorandomness] It is computationally hard to distinguish the output of $\mathsf{VRFHash}(sk, \alpha)$ from a random string if not knowing the corresponding public key $pk$ and proof $\pi$.
\end{description}



%------------------------------------------------

\section*{VRF-based mining}

Cryptocurrency mining consists of two components, namely mining blocks and verifying blocks.
We call the process of mining a block $\mathsf{Work}$, and the process of verifying a block $\mathsf{Verify}$.
Algorithm~\ref{algo:work} and \ref{algo:verify} describe $\mathsf{Work}$ and $\mathsf{Verify}$, respectively.

\vspace{1cm}
\begin{algorithm}[H]
    \caption{$\mathsf{Work}(sk, t, Target)$.}
    \label{algo:work}
    \SetAlgoLined\DontPrintSemicolon
    \KwIn{The secret key $sk$, the block template $t$, and the difficulty parameter $Target$}
    \KwOut{The block $blk$, the VRF output $h$, and the VRF proof $\pi$}
    Initialise $n$, $h$, $blk$ \Comment*[r]{Initialise variables}
    \While (\Comment*[f]{Refresh the nonce}) {$n \gets \mathsf{NextNonce}()$}{
        $blk \gets \mathsf{ConstructBlock}(t, n)$ \Comment*[r]{Assemble the block}
        $h \gets \mathsf{VRFHash}(sk, blk)$ \Comment*[r]{Produce the VRF output}
        \If (\Comment*[f]{If meeting difficulty}) {$h < Target$}{
            break \Comment*[r]{Mining successful}
        }
    }
    $\pi \gets \mathsf{VRFProve}(sk, blk)$ \Comment*[r]{Produce the proof}
    \Return{$blk$, $h$, $\pi$} \Comment*[r]{Return block, hash and proof}
\end{algorithm}


\begin{algorithm}[H]
    \caption{$\mathsf{Verify}(blk, h, \pi, Target)$}
    \label{algo:verify}
    \SetAlgoLined\DontPrintSemicolon
    $pk \gets blk . txs[0] . scriptPubKey$ \Comment*[r]{Find pubkey in coinbase tx}
    $\mathsf{require}(h < Target)$ \Comment*[r]{Hash should meet diff requirement}
    \tcc{Here $\mathsf{VRFVerify}(\cdot)$ ensures:\\
        1. $h$ is generated by the owner of $sk$\\
        2. $h$ is the valid output of $\mathsf{VRFHash}(sk, blk)$}
    $\mathsf{require}(\mathsf{VRFVerify}(pk, blk, h, \pi))$ \;
    $\dots$ \Comment*[l]{Verify other fields}
    $\dots$ \Comment*[l]{Verify transactions}
\end{algorithm}
\vspace{1cm}

\textbf{Work.}
Miners run $\mathsf{Work}$ to mine new blocks.
More specifically, a miner - with his private key $sk$ the block template (a complete block without nonce) $t$ - keeps searching for a nonce $n$ that can make the (VRF) hash $h$ of the block $blk$ to meet the difficulty requirement $Target$.
Once finding a valid $n$, the miner produces the proof $\pi$ of $h$, and appends $blk$ (with $n$), $h$ and $\pi$ to the blockchain.

\textbf{Verify.}
Upon incoming blocks, miners run $\mathsf{Verify}$ to verify their validity.
While other verifications are the same as in hash-based mining, $\mathsf{Verify}$ in VRF-based mining should additionally run $\mathsf{VRFVerify}(\cdot)$ to verify 1) whether $h$ is produced by the owner of $sk$, and 2) whether $h$ is a valid output of $\mathsf{VRFHash}(sk, blk)$.

\textbf{Block structure.}
Different from hash-based mining, in VRF-based mining a block should additionally attach $h$ and $\pi$, but does not need the signature of a block.
Other miners without knowing $sk$ cannot produce $h$, but can use $\pi$ to verify $h$ is generated by someone knowing $sk$.
Through proving the authorship of $h$, $\pi$ also proves the authorship of the block.
Thus, miners only need to sign $h$, but do not need to sign blocks.

%----------------------------------------------------------------------------------------
%	RESULTS 
%----------------------------------------------------------------------------------------

\section*{Instantiating VRF}

In order to implement VRF-based mining, one needs to first instantiate the VRF.
VRF in Algorithm~\ref{algo:standard-ecvrf} has four configurable components, including the elliptic curve and three hash functions.
Three hash functions are:
$H_{1}(\cdot)$ mapping an arbitrary-length string into an elliptic curve element,
$H_{2}(\cdot)$ mapping an elliptic curve element into a fixed-length string, and
$H_{3}(\cdot)$ mapping an arbitrary-length string into a fixed-length string.
In this section, we discuss considerations on choosing these four components for VRF-based mining.

\subsection{Memory-hard mining}

For ASIC-resistant cryptocurrencies using memory-hard hash functions (e.g., Ethereum~\cite{wood2014ethereum} and Monero~\cite{monero}), there are some concerns on designing $H_{1}(\cdot)$ and $H_{2}(\cdot)$.
% VRFHash shoule memory-hard
To make mining memory-hard, $\mathsf{VRFHash}$ should be memory-hard.
% vrfhash steps
$\mathsf{VRFHash}$ of the standardised VRF consists of one $H_{1}(\cdot)$ hashing, one scalar-point multiplication and one $H_{2}(\cdot)$ hashing.
Thus, making VRF-based mining memory-hard can be achieved by making $H_{1}(\cdot)$ or $H_{2}(\cdot)$ memory-hard.
This can be achieved by repetitively executing one or multiple different memory-hard hash functions (such as Ethash~\cite{wiki2017ethash} and CryptoNight~\cite{seigenneocortex}).


\subsection{Preventing partial outsourcing}

The pool operator may have opportunity to outsource a part of mining.
The non-outsourceability is from $\gamma = h^{sk}$, which requires the knowledge of the pool operator's secret key $sk$.
The pool operator can outsource the pre-processing ($h = H_1(\alpha)$) by distributing different $\alpha$s to miners, and can also outsource the post-processing $\beta = H_2(\gamma)$ by distributing different $\gamma$ to miners.

However, this can be extremely I/O intensive for both the pool operator and miners.
For each different block template the pool operator should have a round-trip communication with a miner.

In order to make outsourcing maximally I/O intensive, we recommend to make $H_1(\alpha)$ much heavier than $H_2(\gamma)$. 
This is because outsourcing the post-processing is less I/O intensive than outsourcing the pre-processing for the pool operator.
Once having $\beta$ (the result of $H_2(\gamma)$), the miner can know whether $\beta$ satisfies the difficulty or not, and can only send valid $\beta$s to the pool operator.
Thus, if we make pre-processing more computationally intensive than post-processing, outsourcing the post-processing will no longer be profitable.
This can be achieved by making $H_1(\alpha)$ much heavier than $H_2(\gamma)$.

%----------------------------------------------------------------------------------------
%	REFERENCES
%----------------------------------------------------------------------------------------

% \nocite{*} % Print all references regardless of whether they were cited in the poster or not
\bibliographystyle{plain} % Plain referencing style
\bibliography{refs} % Use the example bibliography file sample.bib

%----------------------------------------------------------------------------------------
%	ACKNOWLEDGEMENTS
%----------------------------------------------------------------------------------------

\section*{Acknowledgements}

We thank Cheng Wang, Omer Shlomovits and John Tromp for their valuable feedback.

%----------------------------------------------------------------------------------------

\end{multicols}
\end{document}